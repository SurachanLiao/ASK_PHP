{"ast":null,"code":"import { CARD_STATUS, DECK_SIZE, CARD_SIZES } from \"../constants\";\nimport cardsData from \"../components/cardsData\"; //half deck size for matching game purpose\n\nconst LIMIT = Math.ceil(DECK_SIZE / 2);\n/**\n * Create new game\n */\n\nexport default (() => {\n  const cards = getRandomCards();\n  const deck = cards.concat(cards);\n\n  while (deck.length > DECK_SIZE) {\n    deck.pop();\n  } // shuffle a given set of card\n\n\n  const shuffledDeck = deck.sort(() => 0.5 - Math.random());\n  return shuffledDeck;\n}); // generate randoms cards from a deck of 52 cards\n\nexport const getRandomCards = () => {\n  const urlArray = [];\n  var rand = new Array(LIMIT); //////// NEED FIX TO GENERATE UNIQUE RANDOM\n  // random cards from the deck\n\n  for (let index = 0; index < LIMIT; index++) {\n    rand[index] = Math.floor(Math.random() * 52);\n  }\n\n  for (let index = 0; index < LIMIT; index++) {\n    urlArray.push({\n      id: index,\n      url: cardsData[rand[index]].image,\n      status: CARD_STATUS.HIDDEN\n    });\n  }\n\n  return urlArray;\n};\n/**\n * Check if the game is completed\n * @param {*} deck\n */\n\nexport const checkGame = deck => {\n  const matches = Object.keys(deck).filter(key => deck[key].status === CARD_STATUS.MATCHED);\n  return matches.length === DECK_SIZE - 1;\n};","map":{"version":3,"sources":["/Users/Smile/ASK_PHP/src/services/GameService.js"],"names":["CARD_STATUS","DECK_SIZE","CARD_SIZES","cardsData","LIMIT","Math","ceil","cards","getRandomCards","deck","concat","length","pop","shuffledDeck","sort","random","urlArray","rand","Array","index","floor","push","id","url","image","status","HIDDEN","checkGame","matches","Object","keys","filter","key","MATCHED"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,UAAjC,QAAmD,cAAnD;AAEA,OAAOC,SAAP,MAAsB,yBAAtB,C,CAEA;;AACA,MAAMC,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUL,SAAS,GAAG,CAAtB,CAAd;AAEA;;;;AAGA,gBAAe,MAAM;AACnB,QAAMM,KAAK,GAAGC,cAAc,EAA5B;AACA,QAAMC,IAAI,GAAGF,KAAK,CAACG,MAAN,CAAaH,KAAb,CAAb;;AAEA,SAAOE,IAAI,CAACE,MAAL,GAAcV,SAArB,EAAgC;AAC9BQ,IAAAA,IAAI,CAACG,GAAL;AACD,GANkB,CAOnB;;;AACA,QAAMC,YAAY,GAAGJ,IAAI,CAACK,IAAL,CAAU,MAAM,MAAMT,IAAI,CAACU,MAAL,EAAtB,CAArB;AAEA,SAAOF,YAAP;AACD,CAXD,E,CAaA;;AACA,OAAO,MAAML,cAAc,GAAG,MAAM;AAElC,QAAMQ,QAAQ,GAAG,EAAjB;AACA,MAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUd,KAAV,CAAX,CAHkC,CAIlC;AACA;;AACA,OAAK,IAAIe,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGf,KAA5B,EAAmCe,KAAK,EAAxC,EAA4C;AACzCF,IAAAA,IAAI,CAACE,KAAD,CAAJ,GAAcd,IAAI,CAACe,KAAL,CAAWf,IAAI,CAACU,MAAL,KAAgB,EAA3B,CAAd;AACF;;AAED,OAAK,IAAII,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGf,KAA5B,EAAmCe,KAAK,EAAxC,EAA4C;AAC1CH,IAAAA,QAAQ,CAACK,IAAT,CAAc;AACZC,MAAAA,EAAE,EAAEH,KADQ;AAEZI,MAAAA,GAAG,EAAEpB,SAAS,CAACc,IAAI,CAACE,KAAD,CAAL,CAAT,CAAuBK,KAFhB;AAGZC,MAAAA,MAAM,EAAEzB,WAAW,CAAC0B;AAHR,KAAd;AAKD;;AAED,SAAOV,QAAP;AACD,CAnBM;AAqBP;;;;;AAIA,OAAO,MAAMW,SAAS,GAAGlB,IAAI,IAAI;AAC/B,QAAMmB,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYrB,IAAZ,EAAkBsB,MAAlB,CACdC,GAAG,IAAIvB,IAAI,CAACuB,GAAD,CAAJ,CAAUP,MAAV,KAAqBzB,WAAW,CAACiC,OAD1B,CAAhB;AAIA,SAAOL,OAAO,CAACjB,MAAR,KAAmBV,SAAS,GAAG,CAAtC;AACD,CANM","sourcesContent":["import { CARD_STATUS, DECK_SIZE, CARD_SIZES } from \"../constants\";\n\nimport cardsData from \"../components/cardsData\";\n\n//half deck size for matching game purpose\nconst LIMIT = Math.ceil(DECK_SIZE / 2);\n\n/**\n * Create new game\n */\nexport default () => {\n  const cards = getRandomCards();\n  const deck = cards.concat(cards);\n\n  while (deck.length > DECK_SIZE) {\n    deck.pop();\n  }\n  // shuffle a given set of card\n  const shuffledDeck = deck.sort(() => 0.5 - Math.random());\n\n  return shuffledDeck;\n};\n\n// generate randoms cards from a deck of 52 cards\nexport const getRandomCards = () => {\n\n  const urlArray = [];\n  var rand = new Array(LIMIT);\n  //////// NEED FIX TO GENERATE UNIQUE RANDOM\n  // random cards from the deck\n  for (let index = 0; index < LIMIT; index++) {\n     rand[index] = Math.floor(Math.random() * 52);\n  }\n\n  for (let index = 0; index < LIMIT; index++) {\n    urlArray.push({\n      id: index,\n      url: cardsData[rand[index]].image,\n      status: CARD_STATUS.HIDDEN\n    });\n  }\n\n  return urlArray;\n};\n\n/**\n * Check if the game is completed\n * @param {*} deck\n */\nexport const checkGame = deck => {\n  const matches = Object.keys(deck).filter(\n    key => deck[key].status === CARD_STATUS.MATCHED\n  );\n\n  return matches.length === DECK_SIZE - 1;\n};\n"]},"metadata":{},"sourceType":"module"}